<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>mine</title>
	<style>
		body {
			font-family: "Computer Modern Serif", "Times New Roman", Times, serif;
			max-width: 800px;
			margin: 0 auto;
			padding: 20px;
			line-height: 1.5;
			color: #222;
			background-color: #fffff8;
		}

		h1,
		h2,
		h3,
		h4,
		h5,
		h6 {
			font-weight: normal;
			margin-top: 1.5em;
			margin-bottom: 0.5em;
		}

		h1 {
			font-size: 2.2em;
		}

		h2 {
			font-size: 1.8em;
		}

		.markdown {
			margin: 1.5em 0;
			text-align: justify;
		}

		.code {
			font-family: "Computer Modern Typewriter", monospace;
			background: #f9f9f9;
			border-radius: 0;
			margin: 1em 0;
			border-left: 3px solid #ddd;
			overflow-x: auto;
		}

		code {
			font-family: "Computer Modern Typewriter", monospace;
		}

		.output {
			margin: 1em 0 2em;
			padding-left: 1.5em;
			border-left: 1px solid #ddd;
		}

		.output-header {
			color: #666;
			font-size: 0.9em;
			margin-bottom: 0.5em;
			font-style: italic;
		}

		.output pre {
			margin: 0.5em 0;
			white-space: pre-wrap;
			font-family: "Computer Modern Typewriter", monospace;
		}

		.error {
			background: #fff5f5;
			padding: 1em;
			border-left: 3px solid #b71c1c;
		}

		.error-name {
			color: #b71c1c;
			font-weight: bold;
		}

		.error-message {
			margin: 0.5em 0;
		}

		.error-traceback {
			font-family: "Computer Modern Typewriter", monospace;
			white-space: pre-wrap;
		}

		img {
			max-width: 100%;
			height: auto;
			display: block;
			margin: 1em auto;
		}

		.json-data {
			background: #f9f9f9;
			padding: 1em;
			font-family: "Computer Modern Typewriter", monospace;
			border-left: 1px solid #ddd;
		}

		pre {
			margin: 0;
		}

		.text-center {
			text-align: center;
		}
	</style>
</head>

<body>
	<h1 class="text-center">mine</h1>
	<h2 class="text-center">April 05, 2025</h2>

	

    
      <div class="markdown">
        <h2>Practical 6</h2>
<p>Aim: Implementation and Time Analysis of Dijikstra's algorithm.</p>

      </div>
    

    

	

    

    
      <div class="code">
        <pre><code>import heapq

def dijikstra(graph, start):
	distances = {node: float("inf") for node in graph}
	distances[start] = 0
	priority_queue = [(0, start)]
	prev_nodes = {node: None for node in graph}
	while priority_queue:
		current_dist, current_node = heapq.heappop(priority_queue)
		if current_dist > distances[current_node]:
			continue
		for neighbor, weight in graph[current_node]:
			distance = current_dist + weight
			if distance < distances[neighbor]:
				distances[neighbor] = distance
				prev_nodes[neighbor] = current_node
				heapq.heappush(priority_queue, (distance, neighbor))

	return distances, prev_nodes

graph = {
	'A': [('B', 1), ('C', 4)],
	'B': [('A', 1), ('C', 2), ('D', 5)],
	'C': [('A', 4), ('B', 2), ('D', 1)],
	'D': [('B', 5), ('C', 1)],
}

distances, prev_nodes = dijikstra(graph, 'A')
print(f"Shortest {distances=}")
print(f"Previous node= {prev_nodes}")
</code></pre>
      </div>

      <div class="output">
        
          
            <pre>Shortest distances={'A': 0, 'B': 1, 'C': 3, 'D': 4}
Previous node= {'A': None, 'B': 'A', 'C': 'B', 'D': 'C'}
</pre>
          
          
          

          
        
      </div>

    

	

    
      <div class="markdown">
        <h3>Complexity Analysis</h3>
<p>Time: O((V + E) logV)</p>
<p>Space: O(V + E)</p>

      </div>
    

    

	

    

    
      <div class="code">
        <pre><code>class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.edges = []

    def add_edge(self, u, v, w):
        self.edges.append([u, v, w])

    def bellman_ford(self, src):
        dist = [float("inf")] * self.V
        dist[src] = 0

        for _ in range(self.V - 1):
            for u, v, w in self.edges:
                if dist[u] != float("inf") and dist[u] + w < dist[v]:
                    dist[v] = dist[u] + w

        for u, v, w in self.edges:
            if dist[u] != float("Inf") and dist[u] + w < dist[v]:
                print("Graph contains negative weight cycle")
                return

        self.print_solution(dist)

    def print_solution(self, dist):
        print("Vertex Distance from Source")
        for i in range(self.V):
            print(f"{i}\t\t{dist[i]}")


g = Graph(5)
g.add_edge(0, 1, -1)
g.add_edge(0, 2, 4)
g.add_edge(1, 2, 3)
g.add_edge(1, 3, 2)
g.add_edge(1, 4, 2)
g.add_edge(3, 2, 5)
g.add_edge(3, 1, 1)
g.add_edge(4, 3, -3)

g.bellman_ford(0)</code></pre>
      </div>

      <div class="output">
        
          
            <pre>Vertex Distance from Source
0		0
1		-1
2		2
3		-2
4		1
</pre>
          
          
          

          
        
      </div>

    

	

    
      <div class="markdown">
        <h3>Complexity Analysis</h3>
<p>Time: O(V x E)</p>
<p>Space: O(V + E)</p>

      </div>
    

    

	

    

    
      <div class="code">
        <pre><code>ppprint (lol)</code></pre>
      </div>

      <div class="output">
        
          
          
          
            <div class="error">
              <div class="error-name">NameError: name 'ppprint' is not defined</div>
              <pre class="error-traceback"><span class="ansi31">---------------------------------------------------------------------------</span>
<span class="ansi31">NameError</span>                                 Traceback (most recent call last)
<span class="ansi36">Cell</span><span class="ansi36"> </span><span class="ansi32">In[1]</span><span class="ansi32">, line 1</span>
<span class="ansi32">----&gt; </span><span class="ansi32">1</span> <span class="ansi43">ppprint</span> (lol)

<span class="ansi31">NameError</span>: name 'ppprint' is not defined</pre>
            </div>
          

          
        
      </div>

    

	
</body>

</html>