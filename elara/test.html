<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>mine</title>
</head>

<body>
	<h1>mine</h1>
	<h2>April 05, 2025</h2>

	
	
	<div class="markdown">
		<h2>Practical 6</h2>
<p>Aim: Implementation and Time Analysis of Dijikstra's algorithm.</p>
	</div>
	
	
	
	
	
	<pre><code class="code">import heapq

def dijikstra(graph, start):
	distances = {node: float("inf") for node in graph}
	distances[start] = 0
	priority_queue = [(0, start)]
	prev_nodes = {node: None for node in graph}
	while priority_queue:
		current_dist, current_node = heapq.heappop(priority_queue)
		if current_dist > distances[current_node]:
			continue
		for neighbor, weight in graph[current_node]:
			distance = current_dist + weight
			if distance < distances[neighbor]:
				distances[neighbor] = distance
				prev_nodes[neighbor] = current_node
				heapq.heappush(priority_queue, (distance, neighbor))

	return distances, prev_nodes

graph = {
	'A': [('B', 1), ('C', 4)],
	'B': [('A', 1), ('C', 2), ('D', 5)],
	'C': [('A', 4), ('B', 2), ('D', 1)],
	'D': [('B', 5), ('C', 1)],
}

distances, prev_nodes = dijikstra(graph, 'A')
print(f"Shortest {distances=}")
print(f"Previous node= {prev_nodes}")
</code></pre>
	<div class="output">
		<h3>Output:</h3>
		
		
			<pre>Shortest distances={'A': 0, 'B': 1, 'C': 3, 'D': 4}
Previous node= {'A': None, 'B': 'A', 'C': 'B', 'D': 'C'}
</pre>
		
		
	</div>
	
	
	
	<div class="markdown">
		<h3>Complexity Analysis</h3>
<p>Time: O((V + E) logV)</p>
<p>Space: O(V + E)</p>
	</div>
	
	
	
	
	
	<pre><code class="code">class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.edges = []

    def add_edge(self, u, v, w):
        self.edges.append([u, v, w])

    def bellman_ford(self, src):
        dist = [float("inf")] * self.V
        dist[src] = 0

        for _ in range(self.V - 1):
            for u, v, w in self.edges:
                if dist[u] != float("inf") and dist[u] + w < dist[v]:
                    dist[v] = dist[u] + w

        for u, v, w in self.edges:
            if dist[u] != float("Inf") and dist[u] + w < dist[v]:
                print("Graph contains negative weight cycle")
                return

        self.print_solution(dist)

    def print_solution(self, dist):
        print("Vertex Distance from Source")
        for i in range(self.V):
            print(f"{i}\t\t{dist[i]}")


g = Graph(5)
g.add_edge(0, 1, -1)
g.add_edge(0, 2, 4)
g.add_edge(1, 2, 3)
g.add_edge(1, 3, 2)
g.add_edge(1, 4, 2)
g.add_edge(3, 2, 5)
g.add_edge(3, 1, 1)
g.add_edge(4, 3, -3)

g.bellman_ford(0)</code></pre>
	<div class="output">
		<h3>Output:</h3>
		
		
			<pre>Vertex Distance from Source
0		0
1		-1
2		2
3		-2
4		1
</pre>
		
		
	</div>
	
	
	
	<div class="markdown">
		<h3>Complexity Analysis</h3>
<p>Time: O(V x E)</p>
<p>Space: O(V + E)</p>
	</div>
	
	
	
</body>

</html>