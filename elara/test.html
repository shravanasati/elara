<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>mine</title>
</head>

<body>
	<h1>mine</h1>
	<h2>April 05, 2025</h2>

	
	
	<div class="markdown">
		## Practical 6

Aim: Implementation and Time Analysis of Dijikstra&#39;s algorithm.
	</div>
	
	
	
	
	
	<pre><code class="code">import heapq

def dijikstra(graph, start):
	distances = {node: float(&#34;inf&#34;) for node in graph}
	distances[start] = 0
	priority_queue = [(0, start)]
	prev_nodes = {node: None for node in graph}
	while priority_queue:
		current_dist, current_node = heapq.heappop(priority_queue)
		if current_dist &gt; distances[current_node]:
			continue
		for neighbor, weight in graph[current_node]:
			distance = current_dist + weight
			if distance &lt; distances[neighbor]:
				distances[neighbor] = distance
				prev_nodes[neighbor] = current_node
				heapq.heappush(priority_queue, (distance, neighbor))

	return distances, prev_nodes

graph = {
	&#39;A&#39;: [(&#39;B&#39;, 1), (&#39;C&#39;, 4)],
	&#39;B&#39;: [(&#39;A&#39;, 1), (&#39;C&#39;, 2), (&#39;D&#39;, 5)],
	&#39;C&#39;: [(&#39;A&#39;, 4), (&#39;B&#39;, 2), (&#39;D&#39;, 1)],
	&#39;D&#39;: [(&#39;B&#39;, 5), (&#39;C&#39;, 1)],
}

distances, prev_nodes = dijikstra(graph, &#39;A&#39;)
print(f&#34;Shortest {distances=}&#34;)
print(f&#34;Previous node= {prev_nodes}&#34;)
</code></pre>
	<div class="output">
		<h3>Output:</h3>
		
		
			<pre>Shortest distances={&#39;A&#39;: 0, &#39;B&#39;: 1, &#39;C&#39;: 3, &#39;D&#39;: 4}
Previous node= {&#39;A&#39;: None, &#39;B&#39;: &#39;A&#39;, &#39;C&#39;: &#39;B&#39;, &#39;D&#39;: &#39;C&#39;}
</pre>
		
		
	</div>
	
	
	
	<div class="markdown">
		### Complexity Analysis

Time: O((V + E) logV)

Space: O(V + E)
	</div>
	
	
	
	
	
	<pre><code class="code">class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.edges = []

    def add_edge(self, u, v, w):
        self.edges.append([u, v, w])

    def bellman_ford(self, src):
        dist = [float(&#34;inf&#34;)] * self.V
        dist[src] = 0

        for _ in range(self.V - 1):
            for u, v, w in self.edges:
                if dist[u] != float(&#34;inf&#34;) and dist[u] + w &lt; dist[v]:
                    dist[v] = dist[u] + w

        for u, v, w in self.edges:
            if dist[u] != float(&#34;Inf&#34;) and dist[u] + w &lt; dist[v]:
                print(&#34;Graph contains negative weight cycle&#34;)
                return

        self.print_solution(dist)

    def print_solution(self, dist):
        print(&#34;Vertex Distance from Source&#34;)
        for i in range(self.V):
            print(f&#34;{i}\t\t{dist[i]}&#34;)


g = Graph(5)
g.add_edge(0, 1, -1)
g.add_edge(0, 2, 4)
g.add_edge(1, 2, 3)
g.add_edge(1, 3, 2)
g.add_edge(1, 4, 2)
g.add_edge(3, 2, 5)
g.add_edge(3, 1, 1)
g.add_edge(4, 3, -3)

g.bellman_ford(0)</code></pre>
	<div class="output">
		<h3>Output:</h3>
		
		
			<pre>Vertex Distance from Source
0		0
1		-1
2		2
3		-2
4		1
</pre>
		
		
	</div>
	
	
	
	<div class="markdown">
		### Complexity Analysis

Time: O(V x E)

Space: O(V + E)
	</div>
	
	
	
</body>

</html>